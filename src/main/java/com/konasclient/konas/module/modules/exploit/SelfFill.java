package com.konasclient.konas.module.modules.exploit;

import com.konasclient.konas.event.events.network.PacketEvent;
import com.konasclient.konas.event.events.player.PushOutOfBlocksEvent;
import com.konasclient.konas.event.events.player.UpdateWalkingPlayerEvent;
import com.konasclient.konas.event.events.world.UpdateEvent;
import com.konasclient.konas.mixin.ClientPlayerEntityAccessor;
import com.konasclient.konas.mixin.PlayerPositionLookS2CPacketAccessor;
import com.konasclient.konas.module.Category;
import com.konasclient.konas.module.Module;
import com.konasclient.konas.setting.Setting;
import com.konasclient.konas.util.chat.Chat;
import com.konasclient.konas.util.client.Timer;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.block.Block;
import net.minecraft.block.Blocks;
import net.minecraft.block.ChestBlock;
import net.minecraft.block.EnderChestBlock;
import net.minecraft.client.gui.screen.DownloadingTerrainScreen;
import net.minecraft.item.BlockItem;
import net.minecraft.item.ItemStack;
import net.minecraft.network.packet.c2s.play.HandSwingC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.network.packet.c2s.play.UpdateSelectedSlotC2SPacket;
import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;

public class SelfFill extends Module {
    private Setting<Float> offset = new Setting<>("Offset", 1F, 30F, -30F, 0.5F);
    private Setting<Boolean> rotate = new Setting<>("Rotate", true);
    private Setting<Boolean> swing = new Setting<>("Swing", true);
    private Setting<Boolean> strict = new Setting<>("Strict", false);
    private Setting<Boolean> onlyEChest = new Setting<>("OnlyChests", false);

    public SelfFill() {
        super("self-fill", "Place block in yourself", 0xFF409BCC, Category.Exploit);
    }

    private State state = State.WAITING;
    private Timer timer = new Timer();

    private enum State {
        WAITING,
        DISABLING
    }

    @EventHandler
    public void onUpdate(UpdateEvent.Post event) {
        if (state == State.DISABLING) {
            if (timer.hasPassed(500)) {
                toggle();
            }
            return;
        }
        if (!mc.player.isOnGround()) {
            toggle();
            return;
        }
        if (mc.world.getBlockState(mc.player.getBlockPos()).getBlock() == Blocks.AIR) {
            BlockPos pos = mc.player.getBlockPos();

            BlockPos currentPos = pos.down();
            Direction currentFace = Direction.UP;

            Vec3d vec = new Vec3d(currentPos.getX() + 0.5, currentPos.getY() + 0.5, currentPos.getZ() + 0.5)
                    .add(new Vec3d(currentFace.getUnitVector()).multiply(0.5));

            if (rotate.getValue()) {
                if (((ClientPlayerEntityAccessor) mc.player).getLastPitch() < 0) {
                    mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.LookOnly(mc.player.yaw, 0, true));
                }
                mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.Both(mc.player.getX(), mc.player.getY(), mc.player.getZ(), mc.player.yaw, 90, true));
                ((ClientPlayerEntityAccessor) mc.player).setLastPitch(90);
            }

            mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.PositionOnly(mc.player.getX(), mc.player.getY() + 0.42, mc.player.getZ(), mc.player.isOnGround()));
            mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.PositionOnly(mc.player.getX(), mc.player.getY() + 0.75, mc.player.getZ(), mc.player.isOnGround()));
            mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.PositionOnly(mc.player.getX(), mc.player.getY() + 1.01, mc.player.getZ(), mc.player.isOnGround()));
            mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.PositionOnly(mc.player.getX(), mc.player.getY() + 1.16, mc.player.getZ(), mc.player.isOnGround()));

            boolean changeItem = mc.player.inventory.selectedSlot != getBlockSlot();
            int startingItem = mc.player.inventory.selectedSlot;

            if (changeItem) {
                mc.player.inventory.selectedSlot = getBlockSlot();
                mc.player.networkHandler.sendPacket(new UpdateSelectedSlotC2SPacket(getBlockSlot()));
            }

            mc.player.networkHandler.sendPacket(new PlayerInteractBlockC2SPacket(Hand.MAIN_HAND, new BlockHitResult(vec, currentFace, currentPos, false)));
            if (swing.getValue()) {
                mc.player.networkHandler.sendPacket(new HandSwingC2SPacket(Hand.MAIN_HAND));
            }

            if (changeItem) {
                mc.player.inventory.selectedSlot = startingItem;
                mc.player.networkHandler.sendPacket(new UpdateSelectedSlotC2SPacket(startingItem));
            }

            mc.player.networkHandler.sendPacket(new PlayerMoveC2SPacket.PositionOnly(mc.player.getX(), mc.player.getY() + offset.getValue(), mc.player.getZ(), false));
            timer.reset();
            state = State.DISABLING;
        } else {
            toggle();
        }
    }

    @EventHandler
    public void onSPacketPlayerPosLook(PacketEvent.Receive event) {
        if (mc.currentScreen instanceof DownloadingTerrainScreen) {
            toggle();
            return;
        }
        if (event.packet instanceof PlayerPositionLookS2CPacket && !strict.getValue()) {
            ((PlayerPositionLookS2CPacketAccessor) event.packet).setYaw(mc.player.yaw);
            ((PlayerPositionLookS2CPacketAccessor) event.packet).setPitch(mc.player.pitch);
            ((PlayerPositionLookS2CPacket) event.packet).getFlags().remove(PlayerPositionLookS2CPacket.Flag.X_ROT);
            ((PlayerPositionLookS2CPacket) event.packet).getFlags().remove(PlayerPositionLookS2CPacket.Flag.Y_ROT);
        }
    }

    @EventHandler
    public void onPushOutOfBlocks(PushOutOfBlocksEvent event) {
        event.setCancelled(true);
    }

    private int getBlockSlot(){
        int slot = -1;
        for (int i = 0; i < 9; i++) {
            final ItemStack stack = mc.player.inventory.getStack(i);
            if (stack != ItemStack.EMPTY && stack.getItem() instanceof BlockItem) {
                final Block block = ((BlockItem) stack.getItem()).getBlock();
                if (((block == Blocks.OBSIDIAN && !onlyEChest.getValue()) || block instanceof EnderChestBlock || block instanceof ChestBlock)) {
                    slot = i;
                    break;
                }
            }
        }
        return slot;
    }

    public void onEnable() {
        if (mc.player == null || mc.world == null) {
            toggle();
            return;
        }
        if (!mc.player.isOnGround()) {
            toggle();
            return;
        }
        state = State.WAITING;
        if (getBlockSlot() == -1) {
            Chat.warning("No blocks found!");
            toggle();
        }
    }
}
