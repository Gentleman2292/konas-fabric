package com.konasclient.konas.module.modules.exploit;

import com.konasclient.konas.event.events.network.PacketEvent;
import com.konasclient.konas.event.events.render.RenderEvent;
import com.konasclient.konas.event.events.world.UpdateEvent;
import com.konasclient.konas.module.Category;
import com.konasclient.konas.module.Module;
import com.konasclient.konas.setting.ColorSetting;
import com.konasclient.konas.setting.Setting;
import com.konasclient.konas.util.render.rendering.ModelRenderer;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.packet.c2s.play.*;
import net.minecraft.util.math.Vec3d;

import java.awt.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.atomic.AtomicBoolean;

public class Blink extends Module {
    private Setting<Boolean> pulse = new Setting<>("Pulse", false);
    private Setting<Boolean> strict = new Setting<>("Strict", false);
    private Setting<Float> factor = new Setting<>("Factor", 1F, 10F, 0.1F, 0.1F);
    private static Setting<Boolean> render = new Setting<>("Render", true);
    public static Setting<ColorSetting> circleColor = new Setting<>("Color", new ColorSetting(0xFFda6464, true)).withVisibility(render::getValue);

    public Blink() {
        super("blink", "FakeLag", 0xFF7F6EE5, Category.Exploit);
    }

    private Queue<Packet> storedPackets = new LinkedList<>();

    private Vec3d lastPos = new Vec3d(0, 0, 0);

    private AtomicBoolean sending = new AtomicBoolean(false);

    @EventHandler
    public void onPacket(PacketEvent.Send event) {
        Packet packet = event.packet;
        if (sending.get()) return;
        if (pulse.getValue()) {
            if (event.packet instanceof PlayerMoveC2SPacket) {
                if (strict.getValue() && !((PlayerMoveC2SPacket) event.packet).isOnGround()) {
                    sending.set(true);
                    while(!storedPackets.isEmpty()) {
                        Packet pckt = storedPackets.poll();
                        mc.player.networkHandler.sendPacket(pckt);
                        if (pckt instanceof PlayerMoveC2SPacket && !(pckt instanceof PlayerMoveC2SPacket.LookOnly)) {
                            lastPos = new Vec3d(((PlayerMoveC2SPacket) pckt).getX(mc.player.getX()), ((PlayerMoveC2SPacket) pckt).getY(mc.player.getY()), ((PlayerMoveC2SPacket) pckt).getZ(mc.player.getZ()));
                        }
                    }
                    sending.set(false);
                    storedPackets.clear();
                } else {
                    event.cancel();
                    storedPackets.add(event.packet);
                }
            }
        } else if (!(packet instanceof ChatMessageC2SPacket || packet instanceof TeleportConfirmC2SPacket || packet instanceof KeepAliveC2SPacket || packet instanceof AdvancementTabC2SPacket || packet instanceof ClientStatusC2SPacket)) {
            event.cancel();
            storedPackets.add(event.packet);
        }
    }

    @EventHandler
    public void onUpdate(UpdateEvent.Pre event) {
        if (pulse.getValue()) {
            if (storedPackets.size() >= factor.getValue() * 10F) {
                sending.set(true);
                while(!storedPackets.isEmpty()) {
                    Packet pckt = storedPackets.poll();
                    mc.player.networkHandler.sendPacket(pckt);
                    if (pckt instanceof PlayerMoveC2SPacket && !(pckt instanceof PlayerMoveC2SPacket.LookOnly)) {
                        lastPos = new Vec3d(((PlayerMoveC2SPacket) pckt).getX(mc.player.getX()), ((PlayerMoveC2SPacket) pckt).getY(mc.player.getY()), ((PlayerMoveC2SPacket) pckt).getZ(mc.player.getZ()));
                    }
                }
                sending.set(false);
                storedPackets.clear();
            }
        }
    }

    @EventHandler
    public void onWorldRender(RenderEvent event) {
        if (mc.player == null || mc.world == null) return;
        if (render.getValue() && lastPos != null) {
            float[] hsb = Color.RGBtoHSB(circleColor.getValue().getRed(), circleColor.getValue().getGreen(), circleColor.getValue().getBlue(), null);
            float initialHue = (float) (System.currentTimeMillis() % 7200L) / 7200F;
            float hue = initialHue;
            int rgb = Color.getHSBColor(hue, hsb[1], hsb[2]).getRGB();
            ArrayList<Vec3d> vecs = new ArrayList<>();
            double x = lastPos.x;
            double y = lastPos.y;
            double z = lastPos.z;
            for (int i = 0; i <= 360; ++i) {
                Vec3d vec = new Vec3d(x + Math.sin((double) i * Math.PI / 180.0) * 0.5D, y + 0.01, z + Math.cos((double) i * Math.PI / 180.0) * 0.5D);
                vecs.add(vec);
            }
            ModelRenderer.LINES.lineWidth = 1.5F;
            for (int j = 0; j < vecs.size() - 1; ++j) {
                int red = (rgb >> 16) & 0xFF;
                int green = (rgb >> 8) & 0xFF;
                int blue = (rgb) & 0xFF;
                com.konasclient.konas.util.render.Color color = new com.konasclient.konas.util.render.Color(circleColor.getValue().getRed() / 255F, circleColor.getValue().getGreen() / 255F, circleColor.getValue().getBlue() / 255F, circleColor.getValue().getAlpha() / 255F);
                if (circleColor.getValue().isCycle()) {
                    color = new com.konasclient.konas.util.render.Color(red / 255F, green / 255F, blue / 255F, circleColor.getValue().getAlpha() / 255F);
                }
                ModelRenderer.LINES.line(vecs.get(j).x, vecs.get(j).y, vecs.get(j).z, vecs.get(j + 1).x, vecs.get(j + 1).y, vecs.get(j + 1).z, color);
                hue += (1F / 360F);
                rgb = Color.getHSBColor(hue, hsb[1], hsb[2]).getRGB();
            }
            ModelRenderer.LINES.lineWidth = 1F;
        }
    }

    @Override
    public void onDisable() {
        if(mc.world == null || mc.player == null) return;
        while(!storedPackets.isEmpty()) {
            mc.player.networkHandler.sendPacket(storedPackets.poll());
        }
    }

    @Override
    public void onEnable() {
        if (mc.player == null || mc.world == null || mc.isIntegratedServerRunning()) {
            this.toggle();
            return;
        }
        lastPos = mc.player.getPos();
        sending.set(false);
        storedPackets.clear();
    }

    @Override
    public String getMetadata() {
        return Integer.toString(storedPackets.size());
    }
}
