package com.konasclient.konas.util.combat;

import com.konasclient.konas.module.modules.combat.AutoCrystal;
import com.konasclient.konas.util.interaction.LookCalculator;
import com.konasclient.konas.util.math.RayTraceHelper;
import net.minecraft.block.AirBlock;
import net.minecraft.block.Blocks;
import net.minecraft.client.MinecraftClient;
import net.minecraft.entity.Entity;
import net.minecraft.entity.decoration.EndCrystalEntity;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;

import java.util.ArrayList;

public class VulnerabilityUtil {
    public static MinecraftClient mc = MinecraftClient.getInstance();

    public static boolean isVulnerable(Entity entity) {
        BlockPos root = entity.getBlockPos();
        return !getVulnerablePositions(root).isEmpty();
    }

    public static ArrayList<BlockPos> getVulnerablePositions(BlockPos root) {
        ArrayList<BlockPos> vP = new ArrayList<>();
        if (!(mc.world.getBlockState(root).getBlock() instanceof AirBlock)) {
            return vP;
        }
        for (Direction facing : Direction.values()) {
            if (facing == Direction.UP || facing == Direction.DOWN) continue;
            if (mc.world.getBlockState(root.offset(facing)).getBlock() instanceof AirBlock) return new ArrayList<BlockPos>();
            if (!(mc.world.getBlockState(root.offset(facing)).getBlock() == Blocks.OBSIDIAN)) continue;
            if (canPlaceCrystal(root.offset(facing, 2).down()) && mc.world.getBlockState(root.offset(facing)).getBlock() != Blocks.AIR) {
                vP.add(root.offset(facing));
            } else if (canPlaceCrystal(root.offset(facing)) && mc.world.getBlockState(root.offset(facing)).getBlock() != Blocks.AIR && (
                    mc.world.getBlockState(root.offset(facing).down()).getBlock() == Blocks.BEDROCK || mc.world.getBlockState(root.offset(facing).down()).getBlock() == Blocks.OBSIDIAN
            )) {
                vP.add(root.offset(facing));
            }
        }
        return vP;
    }

    public static boolean canPlaceCrystal(BlockPos blockPos) {
        if (!(mc.world.getBlockState(blockPos).getBlock() == Blocks.BEDROCK
                || mc.world.getBlockState(blockPos).getBlock() == Blocks.OBSIDIAN)) return false;

        BlockPos boost = blockPos.add(0, 1, 0);

        if (!(mc.world.getBlockState(boost).getBlock() == Blocks.AIR)) return false;

        BlockPos boost2 = blockPos.add(0, 2, 0);

        if (AutoCrystal.protocol.getValue()) {
            if (!(mc.world.getBlockState(boost2).getBlock() == Blocks.AIR)) {
                return false;
            }
        }

        if (!RayTraceHelper.canSee(new Vec3d(blockPos.getX() + 0.5, blockPos.getY() + 1.7, blockPos.getZ() + 0.5), new Vec3d(blockPos.getX() + 0.5, blockPos.getY() + 1.0, blockPos.getZ() + 0.5))) {
            if (LookCalculator.getEyesPos(mc.player).distanceTo(new Vec3d(blockPos.getX() + 0.5, blockPos.getY() + 1.0,blockPos.getZ() + 0.5)) > AutoCrystal.breakWallsRange.getValue()) {
                return false;
            }
        }

        Vec3d playerEyes = LookCalculator.getEyesPos(mc.player);
        boolean canPlace = false;

        if (AutoCrystal.strictDirection.getValue()) {
            for (Vec3d point : AutoCrystal.fastMultiPoint) {
                Vec3d p = new Vec3d(blockPos.getX() + point.getX(), blockPos.getY() + point.getY(), blockPos.getZ() + point.getZ());
                double distanceTo = playerEyes.distanceTo(p);
                if (distanceTo > AutoCrystal.placeRange.getValue()) {
                    continue;
                }
                if (distanceTo > AutoCrystal.placeWallsRange.getValue()) {
                    if (AutoCrystal.strictDirection.getValue()) {
                        BlockHitResult result = mc.world.raycast(new RaycastContext(playerEyes, p, RaycastContext.ShapeType.COLLIDER, RaycastContext.FluidHandling.NONE, mc.player));
                        if (result != null && result.getType() == HitResult.Type.BLOCK && result.getBlockPos().equals(blockPos)) {
                            canPlace = true;
                            break;
                        }
                    }
                } else {
                    canPlace = true;
                    break;
                }
            }
        } else {
            for (Direction dir : Direction.values()) {
                Vec3d p = new Vec3d(blockPos.getX() + 0.5 + dir.getVector().getX() * 0.5,
                        blockPos.getY() + 0.5 + dir.getVector().getY() * 0.5,
                        blockPos.getZ() + 0.5 + dir.getVector().getZ() * 0.5);
                double distanceTo = playerEyes.distanceTo(p);
                if (distanceTo > AutoCrystal.placeRange.getValue()) {
                    continue;
                }
                if (distanceTo > AutoCrystal.placeWallsRange.getValue()) {
                    if (AutoCrystal.strictDirection.getValue()) {
                        BlockHitResult result = mc.world.raycast(new RaycastContext(playerEyes, p, RaycastContext.ShapeType.COLLIDER, RaycastContext.FluidHandling.NONE, mc.player));
                        if (result != null && result.getType() == HitResult.Type.BLOCK && result.getBlockPos().equals(blockPos)) {
                            canPlace = true;
                            break;
                        }
                    }
                } else {
                    canPlace = true;
                    break;
                }
            }
        }

        if (!canPlace) {
            return false;
        }

        return mc.world.getOtherEntities((Entity) null, new Box(blockPos).stretch(0, AutoCrystal.protocol.getValue() ? 2 : 1, 0)).stream()
                .filter(entity -> !AutoCrystal.silentMap.containsKey(entity.getEntityId()) && (!(entity instanceof EndCrystalEntity) || entity.age > 20)).count() == 0;
    }
}

